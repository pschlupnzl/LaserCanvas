/*********************************************************
* Renderer2d.cpp
* 2d vector icons for canvas and mode size renderers
* This file is a collection of  icons to be rendered onto
* 2d and 1d  renderers. They are in vector  form and each
* requires the device context, pen, and other features to
* be prepared before calling.
* Since these routines will be called somewhat frequently
* the code has been kept verbose.
*
* NEW! Version 6 (2006sep22): Hero mirror icons!
* A bit staring at geometry in Matlab yielded the beauti-
* ful smooth and high-resolution mirror icons I've always
* wanted! Source code below.
*
* $PSchlup 2006 $     $Revision 6 $
*********************************************************/
#include "Renderer2d.h"                     // header

#define BLOCKSIZE 0.6182818          // relative width of blocks to optics

/*********************************************************
* Renderer2dIcon
* Switchyard function
*********************************************************/
void Renderer2dIcon(HDC hdc, CVertex *pVx, int x, int y, double dSize, double dAbsAng) {
   if(pVx==NULL) return;                    // ignore if no Vx passed
   switch(pVx->Type()) {
   case CVX_TYPE_MIRROR      :
      Renderer2dMirror(hdc, x, y, dSize, dAbsAng, pVx->ROC(TAN));
      if(pVx->LockedAngle()) Renderer2dMirrorLock(hdc, x, y, dSize, dAbsAng);
      break;
   case CVX_TYPE_LENS        : Renderer2dLens  (hdc, x, y, dSize, dAbsAng, pVx->FL(TAN));  break;
   case CVX_TYPE_FLATMIRROR  :
      Renderer2dMirror(hdc, x, y, dSize, dAbsAng, 0.00);
      if(pVx->LockedAngle()) Renderer2dMirrorLock(hdc, x, y, dSize, dAbsAng);
      break;
   case CVX_TYPE_THERMALLENS : Renderer2dLens  (hdc, x, y, dSize, dAbsAng, pVx->FL(TAN));  break;
   case CVX_TYPE_SCREEN      : Renderer2dScreen(hdc, x, y, dSize, dAbsAng);             break;
   case CVX_TYPE_SOURCE      : Renderer2dSource(hdc, x, y, dSize, dAbsAng);             break;
   case CVX_TYPE_INCRYSTAL   : Renderer2dPlate (hdc, x, y, dSize, dAbsAng, pVx->ROC(TAN)); break;
   case CVX_TYPE_OUTCRYSTAL  : Renderer2dPlate (hdc, x, y, dSize, dAbsAng,-pVx->ROC(TAN)); break;
   case CVX_TYPE_INBREWSTER  : Renderer2dPlate (hdc, x, y, dSize, dAbsAng, pVx->ROC(TAN)); break;
   case CVX_TYPE_OUTBREWSTER : Renderer2dPlate (hdc, x, y, dSize, dAbsAng,-pVx->ROC(TAN)); break;
   case CVX_TYPE_INPLATE     : Renderer2dPlate (hdc, x, y, dSize, dAbsAng, pVx->ROC(TAN)); break;
   case CVX_TYPE_OUTPLATE    : Renderer2dPlate (hdc, x, y, dSize, dAbsAng,-pVx->ROC(TAN)); break;
   case CVX_TYPE_PRISM1      : Renderer2dPrism (hdc, x, y, dSize, dAbsAng, pVx->_Prop(CVXI_PROP_N)); break;
   case CVX_TYPE_PRISM2      : Renderer2dPrism (hdc, x, y, dSize, dAbsAng, pVx->_Prop(CVXI_PROP_N)); break;
   case CVX_TYPE_OUTCOUPLER  : Renderer2dMirror(hdc, x, y, dSize, dAbsAng, pVx->ROC(TAN)); break;
   }
}

/*********************************************************
* Icon Coordinates
*********************************************************/
static double SdDefaultX[] = {-0.25, 0.25,  0.25, -0.25, -0.25};
static double SdDefaultY[] = { 0.25, 0.25, -0.25, -0.25,  0.25};
const int iNumDefault    = 5;

//===Mirrors==============================================
static double SdMirrP05X[55] = { -0.5000, -0.5000, +9.9999, -0.3660, -0.2500, +9.9999, -0.2500, -0.0000, +9.9999, -0.1520, +0.2500, +9.9999, -0.0750, +0.2500, +9.9999, -0.0210, +0.2500, +9.9999, -0.0000, +0.2500, +9.9999, -0.0320, +0.2500, +9.9999, -0.2500, +0.2500, +9.9999, -0.2500, +0.2500, +9.9999, -0.0000, +0.2500, +9.9999, +0.2500, +0.2500, +9.9999, -0.5000, -0.3110, -0.2500, -0.1620, -0.0590, -0.0320, -0.0070, -0.0000, -0.0070, -0.0210, -0.0590, -0.0750, -0.1520, -0.1620, -0.2500, -0.3110, -0.3660, -0.5000, -0.5000};
static double SdMirrP05Y[55] = { -1.0000, -1.0000, +9.9999, -0.8840, -1.0000, +9.9999, -0.7500, -1.0000, +9.9999, -0.5980, -1.0000, +9.9999, -0.4250, -0.7500, +9.9999, -0.2290, -0.5000, +9.9999, -0.0000, -0.2500, +9.9999, +0.2820, -0.0000, +9.9999, +0.7500, +0.2500, +9.9999, +1.0000, +0.5000, +9.9999, +1.0000, +0.7500, +9.9999, +1.0000, +1.0000, +9.9999, +1.0000, +0.8250, +0.7500, +0.6160, +0.3800, +0.2820, +0.1290, -0.0000, -0.1290, -0.2290, -0.3800, -0.4250, -0.5980, -0.6160, -0.7500, -0.8250, -0.8840, -1.0000, -1.0000};
static int SiMirrP05N = 55;

static double SdMirrP06X[51] = { -0.3220, -0.2500, +9.9999, -0.2190, -0.0000, +9.9999, -0.1330, +0.2500, +9.9999, -0.0650, +0.2500, +9.9999, -0.0180, +0.2500, +9.9999, -0.0000, +0.2500, +9.9999, -0.0260, +0.2500, +9.9999, -0.1460, +0.2500, +9.9999, -0.2500, +0.2500, +9.9999, -0.0000, +0.2500, +9.9999, +0.2500, +0.2500, +9.9999, -0.3820, -0.2350, -0.1460, -0.1220, -0.0440, -0.0260, -0.0050, -0.0000, -0.0050, -0.0180, -0.0440, -0.0650, -0.1220, -0.1330, -0.2190, -0.2350, -0.3220, -0.3820};
static double SdMirrP06Y[51] = { -0.9280, -1.0000, +9.9999, -0.7810, -1.0000, +9.9999, -0.6170, -1.0000, +9.9999, -0.4350, -0.7500, +9.9999, -0.2320, -0.5000, +9.9999, -0.0000, -0.2500, +9.9999, +0.2760, -0.0000, +9.9999, +0.6460, +0.2500, +9.9999, +1.0000, +0.5000, +9.9999, +1.0000, +0.7500, +9.9999, +1.0000, +1.0000, +9.9999, +1.0000, +0.8060, +0.6460, +0.5920, +0.3610, +0.2760, +0.1210, -0.0000, -0.1210, -0.2320, -0.3610, -0.4350, -0.5920, -0.6170, -0.7810, -0.8060, -0.9280, -1.0000};
static int SiMirrP06N = 51;

static double SdMirrP07X[51] = { -0.2880, -0.2500, +9.9999, -0.1960, -0.0000, +9.9999, -0.1180, +0.2500, +9.9999, -0.0570, +0.2500, +9.9999, -0.0160, +0.2500, +9.9999, -0.0000, +0.2500, +9.9999, -0.0210, +0.2500, +9.9999, -0.1100, +0.2500, +9.9999, -0.2500, +0.2500, +9.9999, -0.0000, +0.2500, +9.9999, +0.2500, +0.2500, +9.9999, -0.3140, -0.1920, -0.1100, -0.0990, -0.0360, -0.0210, -0.0040, -0.0000, -0.0040, -0.0160, -0.0360, -0.0570, -0.0990, -0.1180, -0.1920, -0.1960, -0.2880, -0.3140};
static double SdMirrP07Y[51] = { -0.9620, -1.0000, +9.9999, -0.8040, -1.0000, +9.9999, -0.6320, -1.0000, +9.9999, -0.4430, -0.7500, +9.9999, -0.2340, -0.5000, +9.9999, -0.0000, -0.2500, +9.9999, +0.2710, -0.0000, +9.9999, +0.6100, +0.2500, +9.9999, +1.0000, +0.5000, +9.9999, +1.0000, +0.7500, +9.9999, +1.0000, +1.0000, +9.9999, +1.0000, +0.7970, +0.6100, +0.5800, +0.3520, +0.2710, +0.1180, -0.0000, -0.1180, -0.2340, -0.3520, -0.4430, -0.5800, -0.6320, -0.7970, -0.8040, -0.9620, -1.0000};
static int SiMirrP07N = 51;

static double SdMirrP08X[51] = { -0.2610, -0.2500, +9.9999, -0.1770, -0.0000, +9.9999, -0.1060, +0.2500, +9.9999, -0.0510, +0.2500, +9.9999, -0.0140, +0.2500, +9.9999, -0.0000, +0.2500, +9.9999, -0.0180, +0.2500, +9.9999, -0.0890, +0.2500, +9.9999, -0.2500, +0.2500, +9.9999, -0.0000, +0.2500, +9.9999, +0.2500, +0.2500, +9.9999, -0.2680, -0.1640, -0.0890, -0.0840, -0.0300, -0.0180, -0.0030, -0.0000, -0.0030, -0.0140, -0.0300, -0.0510, -0.0840, -0.1060, -0.1640, -0.1770, -0.2610, -0.2680};
static double SdMirrP08Y[51] = { -0.9890, -1.0000, +9.9999, -0.8230, -1.0000, +9.9999, -0.6440, -1.0000, +9.9999, -0.4490, -0.7500, +9.9999, -0.2360, -0.5000, +9.9999, -0.0000, -0.2500, +9.9999, +0.2680, -0.0000, +9.9999, +0.5890, +0.2500, +9.9999, +1.0000, +0.5000, +9.9999, +1.0000, +0.7500, +9.9999, +1.0000, +1.0000, +9.9999, +1.0000, +0.7920, +0.5890, +0.5740, +0.3470, +0.2680, +0.1160, -0.0000, -0.1160, -0.2360, -0.3470, -0.4490, -0.5740, -0.6440, -0.7920, -0.8230, -0.9890, -1.0000};
static int SiMirrP08N = 51;

static double SdMirrP10X[48] = { -0.1490, -0.0000, +9.9999, -0.0890, +0.2500, +9.9999, -0.0420, +0.2500, +9.9999, -0.0110, +0.2500, +9.9999, -0.0000, +0.2500, +9.9999, -0.0140, +0.2500, +9.9999, -0.0650, +0.2500, +9.9999, -0.1790, +0.2500, +9.9999, -0.0000, +0.2500, +9.9999, +0.2500, +0.2500, +9.9999, -0.2090, -0.1790, -0.1270, -0.0650, -0.0650, -0.0230, -0.0140, -0.0030, -0.0000, -0.0030, -0.0110, -0.0230, -0.0420, -0.0650, -0.0890, -0.1270, -0.1490, -0.2090};
static double SdMirrP10Y[48] = { -0.8510, -1.0000, +9.9999, -0.6610, -1.0000, +9.9999, -0.4580, -0.7500, +9.9999, -0.2390, -0.5000, +9.9999, -0.0000, -0.2500, +9.9999, +0.2640, -0.0000, +9.9999, +0.5650, +0.2500, +9.9999, +0.9290, +0.5000, +9.9999, +1.0000, +0.7500, +9.9999, +1.0000, +1.0000, +9.9999, +1.0000, +0.9290, +0.7870, +0.5670, +0.5650, +0.3420, +0.2640, +0.1140, -0.0000, -0.1140, -0.2390, -0.3420, -0.4580, -0.5670, -0.6610, -0.7870, -0.8510, -1.0000};
static int SiMirrP10N = 48;

static double SdMirrP12X[45] = { -0.1290, -0.0000, +9.9999, -0.0770, +0.2500, +9.9999, -0.0360, +0.2500, +9.9999, -0.0100, +0.2500, +9.9999, -0.0000, +0.2500, +9.9999, -0.0110, +0.2500, +9.9999, -0.0510, +0.2500, +9.9999, -0.1330, +0.2500, +9.9999, -0.0000, +0.2500, +9.9999, -0.1720, -0.1330, -0.1040, -0.0530, -0.0510, -0.0190, -0.0110, -0.0020, -0.0000, -0.0020, -0.0100, -0.0190, -0.0360, -0.0530, -0.0770, -0.1040, -0.1290, -0.1720};
static double SdMirrP12Y[45] = { -0.8710, -1.0000, +9.9999, -0.6730, -1.0000, +9.9999, -0.4640, -0.7500, +9.9999, -0.2400, -0.5000, +9.9999, -0.0000, -0.2500, +9.9999, +0.2610, -0.0000, +9.9999, +0.5510, +0.2500, +9.9999, +0.8830, +0.5000, +9.9999, +1.0000, +0.7500, +9.9999, +1.0000, +0.8830, +0.7840, +0.5630, +0.5510, +0.3390, +0.2610, +0.1130, -0.0000, -0.1130, -0.2400, -0.3390, -0.4640, -0.5630, -0.6730, -0.7840, -0.8710, -1.0000};
static int SiMirrP12N = 45;

static double SdMirrP15X[48] = { -0.1080, -0.0000, +9.9999, -0.0630, +0.2500, +9.9999, -0.0300, +0.2500, +9.9999, -0.0080, +0.2500, +9.9999, -0.0000, +0.2500, +9.9999, -0.0090, +0.2500, +9.9999, -0.0390, +0.2500, +9.9999, -0.0970, +0.2500, +9.9999, -0.0000, +0.2500, +9.9999, +0.2500, +0.2500, +9.9999, -0.1360, -0.0970, -0.0820, -0.0420, -0.0390, -0.0150, -0.0090, -0.0020, -0.0000, -0.0020, -0.0080, -0.0150, -0.0300, -0.0420, -0.0630, -0.0820, -0.1080, -0.1360};
static double SdMirrP15Y[48] = { -0.8920, -1.0000, +9.9999, -0.6870, -1.0000, +9.9999, -0.4700, -0.7500, +9.9999, -0.2420, -0.5000, +9.9999, -0.0000, -0.2500, +9.9999, +0.2590, -0.0000, +9.9999, +0.5390, +0.2500, +9.9999, +0.8470, +0.5000, +9.9999, +1.0000, +0.7500, +9.9999, +1.0000, +1.0000, +9.9999, +1.0000, +0.8470, +0.7820, +0.5600, +0.5390, +0.3370, +0.2590, +0.1120, -0.0000, -0.1120, -0.2420, -0.3370, -0.4700, -0.5600, -0.6870, -0.7820, -0.8920, -1.0000};
static int SiMirrP15N = 48;

static double SdMirrP20X[48] = { -0.0850, -0.0000, +9.9999, -0.0490, +0.2500, +9.9999, -0.0230, +0.2500, +9.9999, -0.0060, +0.2500, +9.9999, -0.0000, +0.2500, +9.9999, -0.0070, +0.2500, +9.9999, -0.0280, +0.2500, +9.9999, -0.0670, +0.2500, +9.9999, -0.0000, +0.2500, +9.9999, +0.2500, +0.2500, +9.9999, -0.1010, -0.0670, -0.0610, -0.0310, -0.0280, -0.0110, -0.0070, -0.0010, -0.0000, -0.0010, -0.0060, -0.0110, -0.0230, -0.0310, -0.0490, -0.0610, -0.0850, -0.1010};
static double SdMirrP20Y[48] = { -0.9150, -1.0000, +9.9999, -0.7010, -1.0000, +9.9999, -0.4770, -0.7500, +9.9999, -0.2440, -0.5000, +9.9999, -0.0000, -0.2500, +9.9999, +0.2570, -0.0000, +9.9999, +0.5280, +0.2500, +9.9999, +0.8170, +0.5000, +9.9999, +1.0000, +0.7500, +9.9999, +1.0000, +1.0000, +9.9999, +1.0000, +0.8170, +0.7800, +0.5580, +0.5280, +0.3350, +0.2570, +0.1120, -0.0000, -0.1120, -0.2440, -0.3350, -0.4770, -0.5580, -0.7010, -0.7800, -0.9150, -1.0000};
static int SiMirrP20N = 48;

static double SdMirrP30X[48] = { -0.0590, -0.0000, +9.9999, -0.0340, +0.2500, +9.9999, -0.0160, +0.2500, +9.9999, -0.0040, +0.2500, +9.9999, -0.0000, +0.2500, +9.9999, -0.0040, +0.2500, +9.9999, -0.0180, +0.2500, +9.9999, -0.0420, +0.2500, +9.9999, -0.0000, +0.2500, +9.9999, +0.2500, +0.2500, +9.9999, -0.0670, -0.0420, -0.0410, -0.0210, -0.0180, -0.0070, -0.0040, -0.0010, -0.0000, -0.0010, -0.0040, -0.0070, -0.0160, -0.0210, -0.0340, -0.0410, -0.0590, -0.0670};
static double SdMirrP30Y[48] = { -0.9410, -1.0000, +9.9999, -0.7160, -1.0000, +9.9999, -0.4840, -0.7500, +9.9999, -0.2460, -0.5000, +9.9999, -0.0000, -0.2500, +9.9999, +0.2540, -0.0000, +9.9999, +0.5180, +0.2500, +9.9999, +0.7920, +0.5000, +9.9999, +1.0000, +0.7500, +9.9999, +1.0000, +1.0000, +9.9999, +1.0000, +0.7920, +0.7790, +0.5570, +0.5180, +0.3340, +0.2540, +0.1110, -0.0000, -0.1110, -0.2460, -0.3340, -0.4840, -0.5570, -0.7160, -0.7790, -0.9410, -1.0000};
static int SiMirrP30N = 48;

static double SdMirrP50X[48] = { -0.0370, -0.0000, +9.9999, -0.0210, +0.2500, +9.9999, -0.0100, +0.2500, +9.9999, -0.0020, +0.2500, +9.9999, -0.0000, +0.2500, +9.9999, -0.0030, +0.2500, +9.9999, -0.0100, +0.2500, +9.9999, -0.0240, +0.2500, +9.9999, -0.0000, +0.2500, +9.9999, +0.2500, +0.2500, +9.9999, -0.0400, -0.0240, -0.0240, -0.0120, -0.0100, -0.0040, -0.0030, -0.0000, -0.0000, -0.0000, -0.0020, -0.0040, -0.0100, -0.0120, -0.0210, -0.0240, -0.0370, -0.0400};
static double SdMirrP50Y[48] = { -0.9630, -1.0000, +9.9999, -0.7290, -1.0000, +9.9999, -0.4900, -0.7500, +9.9999, -0.2480, -0.5000, +9.9999, -0.0000, -0.2500, +9.9999, +0.2530, -0.0000, +9.9999, +0.5100, +0.2500, +9.9999, +0.7740, +0.5000, +9.9999, +1.0000, +0.7500, +9.9999, +1.0000, +1.0000, +9.9999, +1.0000, +0.7780, +0.7740, +0.5560, +0.5100, +0.3340, +0.2530, +0.1110, -0.0000, -0.1110, -0.2480, -0.3340, -0.4900, -0.5560, -0.7290, -0.7780, -0.9630, -1.0000};
static int SiMirrP50N = 48;

static double SdMirrX[41] = { -0.0000, +0.2500, +9.9999, -0.0000, +0.2500, +9.9999, -0.0000, +0.2500, +9.9999, -0.0000, +0.2500, +9.9999, -0.0000, +0.2500, +9.9999, -0.0000, +0.2500, +9.9999, -0.0000, +0.2500, +9.9999, -0.0000, +0.2500, +9.9999, -0.0000, -0.0000, -0.0000, -0.0000, -0.0000, -0.0000, -0.0000, -0.0000, -0.0000, -0.0000, -0.0000, -0.0000, -0.0000, -0.0000, -0.0000, -0.0000, -0.0000};
static double SdMirrY[41] = { -0.7500, -1.0000, +9.9999, -0.5000, -0.7500, +9.9999, -0.2500, -0.5000, +9.9999, -0.0000, -0.2500, +9.9999, +0.2500, -0.0000, +9.9999, +0.5000, +0.2500, +9.9999, +0.7500, +0.5000, +9.9999, +1.0000, +0.7500, +9.9999, -1.0000, -0.7780, -0.7500, -0.5560, -0.5000, -0.3330, -0.2500, -0.1110, -0.0000, +0.1110, +0.2500, +0.3330, +0.5000, +0.5560, +0.7500, +0.7780, +1.0000};
static int SiMirrN = 41;

static double SdMirrM50X[45] = { +0.0240, +0.2500, +9.9999, +0.0100, +0.2900, +9.9999, +0.0030, +0.2900, +9.9999, -0.0000, +0.2900, +9.9999, +0.0020, +0.2900, +9.9999, +0.0100, +0.2900, +9.9999, +0.0210, +0.2900, +9.9999, +0.0370, +0.2900, +9.9999, +0.2500, +0.2900, +9.9999, +0.0400, +0.0240, +0.0240, +0.0120, +0.0100, +0.0040, +0.0030, -0.0000, -0.0000, -0.0000, +0.0020, +0.0040, +0.0100, +0.0120, +0.0210, +0.0240, +0.0370, +0.0400};
static double SdMirrM50Y[45] = { -0.7740, -1.0000, +9.9999, -0.5100, -0.7900, +9.9999, -0.2530, -0.5400, +9.9999, -0.0000, -0.2900, +9.9999, +0.2480, -0.0400, +9.9999, +0.4900, +0.2100, +9.9999, +0.7290, +0.4600, +9.9999, +0.9630, +0.7100, +9.9999, +1.0000, +0.9600, +9.9999, -1.0000, -0.7780, -0.7740, -0.5560, -0.5100, -0.3340, -0.2530, -0.1110, -0.0000, +0.1110, +0.2480, +0.3340, +0.4900, +0.5560, +0.7290, +0.7780, +0.9630, +1.0000};
static int SiMirrM50N = 45;

static double SdMirrM30X[45] = { +0.0420, +0.2500, +9.9999, +0.0180, +0.3170, +9.9999, +0.0040, +0.3170, +9.9999, -0.0000, +0.3170, +9.9999, +0.0040, +0.3170, +9.9999, +0.0160, +0.3170, +9.9999, +0.0340, +0.3170, +9.9999, +0.0590, +0.3170, +9.9999, +0.2500, +0.3170, +9.9999, +0.0670, +0.0420, +0.0410, +0.0210, +0.0180, +0.0070, +0.0040, +0.0010, -0.0000, +0.0010, +0.0040, +0.0070, +0.0160, +0.0210, +0.0340, +0.0410, +0.0590, +0.0670};
static double SdMirrM30Y[45] = { -0.7920, -1.0000, +9.9999, -0.5180, -0.8170, +9.9999, -0.2540, -0.5670, +9.9999, -0.0000, -0.3170, +9.9999, +0.2460, -0.0670, +9.9999, +0.4840, +0.1830, +9.9999, +0.7160, +0.4330, +9.9999, +0.9410, +0.6830, +9.9999, +1.0000, +0.9330, +9.9999, -1.0000, -0.7920, -0.7790, -0.5570, -0.5180, -0.3340, -0.2540, -0.1110, -0.0000, +0.1110, +0.2460, +0.3340, +0.4840, +0.5570, +0.7160, +0.7790, +0.9410, +1.0000};
static int SiMirrM30N = 45;

static double SdMirrM20X[45] = { +0.0670, +0.2500, +9.9999, +0.0280, +0.3510, +9.9999, +0.0070, +0.3510, +9.9999, -0.0000, +0.3510, +9.9999, +0.0060, +0.3510, +9.9999, +0.0230, +0.3510, +9.9999, +0.0490, +0.3510, +9.9999, +0.0850, +0.3510, +9.9999, +0.2500, +0.3510, +9.9999, +0.1010, +0.0670, +0.0610, +0.0310, +0.0280, +0.0110, +0.0070, +0.0010, -0.0000, +0.0010, +0.0060, +0.0110, +0.0230, +0.0310, +0.0490, +0.0610, +0.0850, +0.1010};
static double SdMirrM20Y[45] = { -0.8170, -1.0000, +9.9999, -0.5280, -0.8510, +9.9999, -0.2570, -0.6010, +9.9999, -0.0000, -0.3510, +9.9999, +0.2440, -0.1010, +9.9999, +0.4770, +0.1490, +9.9999, +0.7010, +0.3990, +9.9999, +0.9150, +0.6490, +9.9999, +1.0000, +0.8990, +9.9999, -1.0000, -0.8170, -0.7800, -0.5580, -0.5280, -0.3350, -0.2570, -0.1120, -0.0000, +0.1120, +0.2440, +0.3350, +0.4770, +0.5580, +0.7010, +0.7800, +0.9150, +1.0000};
static int SiMirrM20N = 45;

static double SdMirrM15X[45] = { +0.0970, +0.2500, +9.9999, +0.0390, +0.3860, +9.9999, +0.0090, +0.3860, +9.9999, -0.0000, +0.3860, +9.9999, +0.0080, +0.3860, +9.9999, +0.0300, +0.3860, +9.9999, +0.0630, +0.3860, +9.9999, +0.1080, +0.3860, +9.9999, +0.2500, +0.3860, +9.9999, +0.1360, +0.0970, +0.0820, +0.0420, +0.0390, +0.0150, +0.0090, +0.0020, -0.0000, +0.0020, +0.0080, +0.0150, +0.0300, +0.0420, +0.0630, +0.0820, +0.1080, +0.1360};
static double SdMirrM15Y[45] = { -0.8470, -1.0000, +9.9999, -0.5390, -0.8860, +9.9999, -0.2590, -0.6360, +9.9999, -0.0000, -0.3860, +9.9999, +0.2420, -0.1360, +9.9999, +0.4700, +0.1140, +9.9999, +0.6870, +0.3640, +9.9999, +0.8920, +0.6140, +9.9999, +1.0000, +0.8640, +9.9999, -1.0000, -0.8470, -0.7820, -0.5600, -0.5390, -0.3370, -0.2590, -0.1120, -0.0000, +0.1120, +0.2420, +0.3370, +0.4700, +0.5600, +0.6870, +0.7820, +0.8920, +1.0000};
static int SiMirrM15N = 45;

static double SdMirrM12X[45] = { +0.1330, +0.2500, +9.9999, +0.0510, +0.4220, +9.9999, +0.0110, +0.4220, +9.9999, -0.0000, +0.4220, +9.9999, +0.0100, +0.4220, +9.9999, +0.0360, +0.4220, +9.9999, +0.0770, +0.4220, +9.9999, +0.1290, +0.4220, +9.9999, +0.2500, +0.4220, +9.9999, +0.1720, +0.1330, +0.1040, +0.0530, +0.0510, +0.0190, +0.0110, +0.0020, -0.0000, +0.0020, +0.0100, +0.0190, +0.0360, +0.0530, +0.0770, +0.1040, +0.1290, +0.1720};
static double SdMirrM12Y[45] = { -0.8830, -1.0000, +9.9999, -0.5510, -0.9220, +9.9999, -0.2610, -0.6720, +9.9999, -0.0000, -0.4220, +9.9999, +0.2400, -0.1720, +9.9999, +0.4640, +0.0780, +9.9999, +0.6730, +0.3280, +9.9999, +0.8710, +0.5780, +9.9999, +1.0000, +0.8280, +9.9999, -1.0000, -0.8830, -0.7840, -0.5630, -0.5510, -0.3390, -0.2610, -0.1130, -0.0000, +0.1130, +0.2400, +0.3390, +0.4640, +0.5630, +0.6730, +0.7840, +0.8710, +1.0000};
static int SiMirrM12N = 45;

static double SdMirrM10X[45] = { +0.1790, +0.2500, +9.9999, +0.0650, +0.4590, +9.9999, +0.0140, +0.4590, +9.9999, -0.0000, +0.4590, +9.9999, +0.0110, +0.4590, +9.9999, +0.0420, +0.4590, +9.9999, +0.0890, +0.4590, +9.9999, +0.1490, +0.4590, +9.9999, +0.2500, +0.4590, +9.9999, +0.2090, +0.1790, +0.1270, +0.0650, +0.0650, +0.0230, +0.0140, +0.0030, -0.0000, +0.0030, +0.0110, +0.0230, +0.0420, +0.0650, +0.0890, +0.1270, +0.1490, +0.2090};
static double SdMirrM10Y[45] = { -0.9290, -1.0000, +9.9999, -0.5650, -0.9590, +9.9999, -0.2640, -0.7090, +9.9999, -0.0000, -0.4590, +9.9999, +0.2390, -0.2090, +9.9999, +0.4580, +0.0410, +9.9999, +0.6610, +0.2910, +9.9999, +0.8510, +0.5410, +9.9999, +1.0000, +0.7910, +9.9999, -1.0000, -0.9290, -0.7870, -0.5670, -0.5650, -0.3420, -0.2640, -0.1140, -0.0000, +0.1140, +0.2390, +0.3420, +0.4580, +0.5670, +0.6610, +0.7870, +0.8510, +1.0000};
static int SiMirrM10N = 45;

static double SdMirrM08X[45] = { +0.0890, +0.5000, +9.9999, +0.0180, +0.5180, +9.9999, -0.0000, +0.5180, +9.9999, +0.0140, +0.5180, +9.9999, +0.0510, +0.5180, +9.9999, +0.1060, +0.5180, +9.9999, +0.1770, +0.5180, +9.9999, +0.2610, +0.5180, +9.9999, +0.5000, +0.5180, +9.9999, +0.2680, +0.1640, +0.0890, +0.0840, +0.0300, +0.0180, +0.0030, -0.0000, +0.0030, +0.0140, +0.0300, +0.0510, +0.0840, +0.1060, +0.1640, +0.1770, +0.2610, +0.2680};
static double SdMirrM08Y[45] = { -0.5890, -1.0000, +9.9999, -0.2680, -0.7680, +9.9999, -0.0000, -0.5180, +9.9999, +0.2360, -0.2680, +9.9999, +0.4490, -0.0180, +9.9999, +0.6440, +0.2320, +9.9999, +0.8230, +0.4820, +9.9999, +0.9890, +0.7320, +9.9999, +1.0000, +0.9820, +9.9999, -1.0000, -0.7920, -0.5890, -0.5740, -0.3470, -0.2680, -0.1160, -0.0000, +0.1160, +0.2360, +0.3470, +0.4490, +0.5740, +0.6440, +0.7920, +0.8230, +0.9890, +1.0000};
static int SiMirrM08N = 45;

static double SdMirrM07X[45] = { +0.1100, +0.5000, +9.9999, +0.0210, +0.5640, +9.9999, -0.0000, +0.5640, +9.9999, +0.0160, +0.5640, +9.9999, +0.0570, +0.5640, +9.9999, +0.1180, +0.5640, +9.9999, +0.1960, +0.5640, +9.9999, +0.2880, +0.5640, +9.9999, +0.5000, +0.5640, +9.9999, +0.3140, +0.1920, +0.1100, +0.0990, +0.0360, +0.0210, +0.0040, -0.0000, +0.0040, +0.0160, +0.0360, +0.0570, +0.0990, +0.1180, +0.1920, +0.1960, +0.2880, +0.3140};
static double SdMirrM07Y[45] = { -0.6100, -1.0000, +9.9999, -0.2710, -0.8140, +9.9999, -0.0000, -0.5640, +9.9999, +0.2340, -0.3140, +9.9999, +0.4430, -0.0640, +9.9999, +0.6320, +0.1860, +9.9999, +0.8040, +0.4360, +9.9999, +0.9620, +0.6860, +9.9999, +1.0000, +0.9360, +9.9999, -1.0000, -0.7970, -0.6100, -0.5800, -0.3520, -0.2710, -0.1180, -0.0000, +0.1180, +0.2340, +0.3520, +0.4430, +0.5800, +0.6320, +0.7970, +0.8040, +0.9620, +1.0000};
static int SiMirrM07N = 45;

static double SdMirrM06X[45] = { +0.1460, +0.5000, +9.9999, +0.0260, +0.6320, +9.9999, -0.0000, +0.6320, +9.9999, +0.0180, +0.6320, +9.9999, +0.0650, +0.6320, +9.9999, +0.1330, +0.6320, +9.9999, +0.2190, +0.6320, +9.9999, +0.3220, +0.6320, +9.9999, +0.5000, +0.6320, +9.9999, +0.3820, +0.2350, +0.1460, +0.1220, +0.0440, +0.0260, +0.0050, -0.0000, +0.0050, +0.0180, +0.0440, +0.0650, +0.1220, +0.1330, +0.2190, +0.2350, +0.3220, +0.3820};
static double SdMirrM06Y[45] = { -0.6460, -1.0000, +9.9999, -0.2760, -0.8820, +9.9999, -0.0000, -0.6320, +9.9999, +0.2320, -0.3820, +9.9999, +0.4350, -0.1320, +9.9999, +0.6170, +0.1180, +9.9999, +0.7810, +0.3680, +9.9999, +0.9280, +0.6180, +9.9999, +1.0000, +0.8680, +9.9999, -1.0000, -0.8060, -0.6460, -0.5920, -0.3610, -0.2760, -0.1210, -0.0000, +0.1210, +0.2320, +0.3610, +0.4350, +0.5920, +0.6170, +0.7810, +0.8060, +0.9280, +1.0000};
static int SiMirrM06N = 45;

static double SdMirrM05X[49] = { +0.2500, +0.5000, +9.9999, +0.0320, +0.7500, +9.9999, -0.0000, +0.7500, +9.9999, +0.0210, +0.7500, +9.9999, +0.0750, +0.7500, +9.9999, +0.1520, +0.7500, +9.9999, +0.2500, +0.7500, +9.9999, +0.3660, +0.7500, +9.9999, +0.5000, +0.7500, +9.9999, +0.7500, +0.7500, +9.9999, +0.5000, +0.3110, +0.2500, +0.1620, +0.0590, +0.0320, +0.0070, -0.0000, +0.0070, +0.0210, +0.0590, +0.0750, +0.1520, +0.1620, +0.2500, +0.3110, +0.3660, +0.5000, +0.5000};
static double SdMirrM05Y[49] = { -0.7500, -1.0000, +9.9999, -0.2820, -1.0000, +9.9999, -0.0000, -0.7500, +9.9999, +0.2290, -0.5000, +9.9999, +0.4250, -0.2500, +9.9999, +0.5980, -0.0000, +9.9999, +0.7500, +0.2500, +9.9999, +0.8840, +0.5000, +9.9999, +1.0000, +0.7500, +9.9999, +1.0000, +1.0000, +9.9999, -1.0000, -0.8250, -0.7500, -0.6160, -0.3800, -0.2820, -0.1290, -0.0000, +0.1290, +0.2290, +0.3800, +0.4250, +0.5980, +0.6160, +0.7500, +0.8250, +0.8840, +1.0000, +1.0000};
static int SiMirrM05N = 49;

//---Mirror lock--------------------------------
//static double SdMirrLkX[17]   = { -0.0000, -0.1951, -0.3827, -0.5556, -0.7071, -0.8315, -0.9239, -0.9808, -1.0000, -0.9808, -0.9239, -0.8315, -0.7071, -0.5556, -0.3827, -0.1951, -0.0000 };
//static double SdMirrLkY[17]   = { -1.0000, -0.9808, -0.9239, -0.8315, -0.7071, -0.5556, -0.3827, -0.1951, +0.0000, +0.1951, +0.3827, +0.5556, +0.7071, +0.8315, +0.9239, +0.9808, +1.0000 };
//static int SiMirrLk = 17;
static double SdMirrLkX[5] = { -0.6000, -0.3000, +9.9999, -0.2000, -0.1000 };
static double SdMirrLkY[5] = {  0.0000,  0.0000, +9.9999,  0.0000,  0.0000 };
static int SiMirrLkN = 5;

//---Mirror spawn-------------------------------
static double SdSpawnSysX[] = {0.00,+0.60,+0.53,+1.00,+0.53,+0.60};
static double SdSpawnSysY[] = {0.00, 0.00,-0.25, 0.00,+0.25, 0.00};
static int SiNumSpawnSys    = 6;

//---Mirror graph-------------------------------
static double SdGraphX[45] = { +0.0000, +0.0000, -0.0300, +0.0000, +0.0300, +0.0000, +9.9999, +0.0000, +0.5400, +0.5100, +0.6000, +0.5100, +0.5400, +9.9999, +0.0600, +0.0940, +0.1290, +0.1630, +0.1970, +0.2310, +0.2660, +0.3000, +0.3340, +0.3690, +0.4030, +0.4370, +0.4710, +0.5060, +0.5400, +9.9999, +0.1200, +0.1250, +0.1380, +0.1590, +0.1880, +0.2220, +0.2600, +0.3000, +0.3400, +0.3780, +0.4120, +0.4410, +0.4620, +0.4750, +0.4800};
static double SdGraphY[45] = { +0.0000, -0.4200, -0.3900, -0.4800, -0.3900, -0.4200, +9.9999, +0.0000, +0.0000, +0.0300, +0.0000, -0.0300, +0.0000, +9.9999, -0.4560, -0.3480, -0.2670, -0.2090, -0.1670, -0.1400, -0.1250, -0.1200, -0.1250, -0.1400, -0.1670, -0.2090, -0.2670, -0.3480, -0.4560, +9.9999, -0.4560, -0.4230, -0.3910, -0.3580, -0.3260, -0.2930, -0.2610, -0.2280, -0.1950, -0.1630, -0.1300, -0.0980, -0.0650, -0.0330, +0.0000};
static int SiGraphN = 45;

//===Lenses===============================================
static double SdLensX[10] = {-0.20, 0.00, 0.20, 9.99, 0.00,  0.00, 9.99, -0.20,  0.00,  0.20};
static double SdLensY[10] = { 0.70, 1.00, 0.70, 9.99, 1.00, -1.00, 9.99, -0.70, -1.00, -0.70};
static int SiLensN = 10;

static double SdLensM05X[33] = { -0.6250, -0.5070, -0.4030, -0.3140, -0.2400, -0.1840, -0.1460, -0.1270, -0.1270, -0.1460, -0.1840, -0.2400, -0.3140, -0.4030, -0.5070, -0.6250, +0.6250, +0.5070, +0.4030, +0.3140, +0.2400, +0.1840, +0.1460, +0.1270, +0.1270, +0.1460, +0.1840, +0.2400, +0.3140, +0.4030, +0.5070, +0.6250, -0.6250};
static double SdLensM05Y[33] = { -1.0000, -0.9000, -0.7860, -0.6600, -0.5240, -0.3800, -0.2300, -0.0770, +0.0770, +0.2300, +0.3800, +0.5240, +0.6600, +0.7860, +0.9000, +1.0000, +1.0000, +0.9000, +0.7860, +0.6600, +0.5240, +0.3800, +0.2300, +0.0770, -0.0770, -0.2300, -0.3800, -0.5240, -0.6600, -0.7860, -0.9000, -1.0000, -1.0000};
static int SiLensM05N = 33;

static double SdLensM06X[33] = { -0.5070, -0.4150, -0.3350, -0.2660, -0.2110, -0.1690, -0.1410, -0.1270, -0.1270, -0.1410, -0.1690, -0.2110, -0.2660, -0.3350, -0.4150, -0.5070, +0.5070, +0.4150, +0.3350, +0.2660, +0.2110, +0.1690, +0.1410, +0.1270, +0.1270, +0.1410, +0.1690, +0.2110, +0.2660, +0.3350, +0.4150, +0.5070, -0.5070};
static double SdLensM06Y[33] = { -1.0000, -0.8870, -0.7650, -0.6360, -0.5010, -0.3610, -0.2180, -0.0730, +0.0730, +0.2180, +0.3610, +0.5010, +0.6360, +0.7650, +0.8870, +1.0000, +1.0000, +0.8870, +0.7650, +0.6360, +0.5010, +0.3610, +0.2180, +0.0730, -0.0730, -0.2180, -0.3610, -0.5010, -0.6360, -0.7650, -0.8870, -1.0000, -1.0000};
static int SiLensM06N = 33;

static double SdLensM07X[33] = { -0.4390, -0.3630, -0.2960, -0.2400, -0.1950, -0.1610, -0.1380, -0.1260, -0.1260, -0.1380, -0.1610, -0.1950, -0.2400, -0.2960, -0.3630, -0.4390, +0.4390, +0.3630, +0.2960, +0.2400, +0.1950, +0.1610, +0.1380, +0.1260, +0.1260, +0.1380, +0.1610, +0.1950, +0.2400, +0.2960, +0.3630, +0.4390, -0.4390};
static double SdLensM07Y[33] = { -1.0000, -0.8800, -0.7550, -0.6250, -0.4900, -0.3520, -0.2120, -0.0710, +0.0710, +0.2120, +0.3520, +0.4900, +0.6250, +0.7550, +0.8800, +1.0000, +1.0000, +0.8800, +0.7550, +0.6250, +0.4900, +0.3520, +0.2120, +0.0710, -0.0710, -0.2120, -0.3520, -0.4900, -0.6250, -0.7550, -0.8800, -1.0000, -1.0000};
static int SiLensM07N = 33;

static double SdLensM08X[33] = { -0.3930, -0.3270, -0.2710, -0.2230, -0.1840, -0.1550, -0.1360, -0.1260, -0.1260, -0.1360, -0.1550, -0.1840, -0.2230, -0.2710, -0.3270, -0.3930, +0.3930, +0.3270, +0.2710, +0.2230, +0.1840, +0.1550, +0.1360, +0.1260, +0.1260, +0.1360, +0.1550, +0.1840, +0.2230, +0.2710, +0.3270, +0.3930, -0.3930};
static double SdLensM08Y[33] = { -1.0000, -0.8770, -0.7490, -0.6180, -0.4840, -0.3470, -0.2090, -0.0700, +0.0700, +0.2090, +0.3470, +0.4840, +0.6180, +0.7490, +0.8770, +1.0000, +1.0000, +0.8770, +0.7490, +0.6180, +0.4840, +0.3470, +0.2090, +0.0700, -0.0700, -0.2090, -0.3470, -0.4840, -0.6180, -0.7490, -0.8770, -1.0000, -1.0000};
static int SiLensM08N = 33;

static double SdLensM10X[33] = { -0.3340, -0.2820, -0.2380, -0.2010, -0.1710, -0.1480, -0.1330, -0.1260, -0.1260, -0.1330, -0.1480, -0.1710, -0.2010, -0.2380, -0.2820, -0.3340, +0.3340, +0.2820, +0.2380, +0.2010, +0.1710, +0.1480, +0.1330, +0.1260, +0.1260, +0.1330, +0.1480, +0.1710, +0.2010, +0.2380, +0.2820, +0.3340, -0.3340};
static double SdLensM10Y[33] = { -1.0000, -0.8730, -0.7430, -0.6110, -0.4770, -0.3420, -0.2060, -0.0690, +0.0690, +0.2060, +0.3420, +0.4770, +0.6110, +0.7430, +0.8730, +1.0000, +1.0000, +0.8730, +0.7430, +0.6110, +0.4770, +0.3420, +0.2060, +0.0690, -0.0690, -0.2060, -0.3420, -0.4770, -0.6110, -0.7430, -0.8730, -1.0000, -1.0000};
static int SiLensM10N = 33;

static double SdLensM12X[33] = { -0.2970, -0.2540, -0.2180, -0.1870, -0.1630, -0.1440, -0.1320, -0.1260, -0.1260, -0.1320, -0.1440, -0.1630, -0.1870, -0.2180, -0.2540, -0.2970, +0.2970, +0.2540, +0.2180, +0.1870, +0.1630, +0.1440, +0.1320, +0.1260, +0.1260, +0.1320, +0.1440, +0.1630, +0.1870, +0.2180, +0.2540, +0.2970, -0.2970};
static double SdLensM12Y[33] = { -1.0000, -0.8710, -0.7400, -0.6070, -0.4740, -0.3390, -0.2040, -0.0680, +0.0680, +0.2040, +0.3390, +0.4740, +0.6070, +0.7400, +0.8710, +1.0000, +1.0000, +0.8710, +0.7400, +0.6070, +0.4740, +0.3390, +0.2040, +0.0680, -0.0680, -0.2040, -0.3390, -0.4740, -0.6070, -0.7400, -0.8710, -1.0000, -1.0000};
static int SiLensM12N = 33;

static double SdLensM15X[33] = { -0.2610, -0.2270, -0.1980, -0.1740, -0.1550, -0.1400, -0.1300, -0.1260, -0.1260, -0.1300, -0.1400, -0.1550, -0.1740, -0.1980, -0.2270, -0.2610, +0.2610, +0.2270, +0.1980, +0.1740, +0.1550, +0.1400, +0.1300, +0.1260, +0.1260, +0.1300, +0.1400, +0.1550, +0.1740, +0.1980, +0.2270, +0.2610, -0.2610};
static double SdLensM15Y[33] = { -1.0000, -0.8690, -0.7370, -0.6050, -0.4710, -0.3370, -0.2020, -0.0670, +0.0670, +0.2020, +0.3370, +0.4710, +0.6050, +0.7370, +0.8690, +1.0000, +1.0000, +0.8690, +0.7370, +0.6050, +0.4710, +0.3370, +0.2020, +0.0670, -0.0670, -0.2020, -0.3370, -0.4710, -0.6050, -0.7370, -0.8690, -1.0000, -1.0000};
static int SiLensM15N = 33;

static double SdLensM20X[33] = { -0.2260, -0.2010, -0.1790, -0.1610, -0.1470, -0.1360, -0.1290, -0.1250, -0.1250, -0.1290, -0.1360, -0.1470, -0.1610, -0.1790, -0.2010, -0.2260, +0.2260, +0.2010, +0.1790, +0.1610, +0.1470, +0.1360, +0.1290, +0.1250, +0.1250, +0.1290, +0.1360, +0.1470, +0.1610, +0.1790, +0.2010, +0.2260, -0.2260};
static double SdLensM20Y[33] = { -1.0000, -0.8680, -0.7360, -0.6030, -0.4690, -0.3350, -0.2010, -0.0670, +0.0670, +0.2010, +0.3350, +0.4690, +0.6030, +0.7360, +0.8680, +1.0000, +1.0000, +0.8680, +0.7360, +0.6030, +0.4690, +0.3350, +0.2010, +0.0670, -0.0670, -0.2010, -0.3350, -0.4690, -0.6030, -0.7360, -0.8680, -1.0000, -1.0000};
static int SiLensM20N = 33;

static double SdLensM30X[33] = { -0.1920, -0.1750, -0.1610, -0.1490, -0.1400, -0.1320, -0.1280, -0.1250, -0.1250, -0.1280, -0.1320, -0.1400, -0.1490, -0.1610, -0.1750, -0.1920, +0.1920, +0.1750, +0.1610, +0.1490, +0.1400, +0.1320, +0.1280, +0.1250, +0.1250, +0.1280, +0.1320, +0.1400, +0.1490, +0.1610, +0.1750, +0.1920, -0.1920};
static double SdLensM30Y[33] = { -1.0000, -0.8670, -0.7340, -0.6010, -0.4680, -0.3340, -0.2010, -0.0670, +0.0670, +0.2010, +0.3340, +0.4680, +0.6010, +0.7340, +0.8670, +1.0000, +1.0000, +0.8670, +0.7340, +0.6010, +0.4680, +0.3340, +0.2010, +0.0670, -0.0670, -0.2010, -0.3340, -0.4680, -0.6010, -0.7340, -0.8670, -1.0000, -1.0000};
static int SiLensM30N = 33;

static double SdLensP30X[33] = { -0.0250, -0.0420, -0.0560, -0.0680, -0.0770, -0.0850, -0.0890, -0.0920, -0.0920, -0.0890, -0.0850, -0.0770, -0.0680, -0.0560, -0.0420, -0.0250, +0.0250, +0.0420, +0.0560, +0.0680, +0.0770, +0.0850, +0.0890, +0.0920, +0.0920, +0.0890, +0.0850, +0.0770, +0.0680, +0.0560, +0.0420, +0.0250, -0.0250};
static double SdLensP30Y[33] = { -1.0000, -0.8670, -0.7340, -0.6010, -0.4680, -0.3340, -0.2010, -0.0670, +0.0670, +0.2010, +0.3340, +0.4680, +0.6010, +0.7340, +0.8670, +1.0000, +1.0000, +0.8670, +0.7340, +0.6010, +0.4680, +0.3340, +0.2010, +0.0670, -0.0670, -0.2010, -0.3340, -0.4680, -0.6010, -0.7340, -0.8670, -1.0000, -1.0000};
static int SiLensP30N = 33;

static double SdLensP20X[33] = { -0.0250, -0.0500, -0.0720, -0.0900, -0.1040, -0.1150, -0.1220, -0.1260, -0.1260, -0.1220, -0.1150, -0.1040, -0.0900, -0.0720, -0.0500, -0.0250, +0.0250, +0.0500, +0.0720, +0.0900, +0.1040, +0.1150, +0.1220, +0.1260, +0.1260, +0.1220, +0.1150, +0.1040, +0.0900, +0.0720, +0.0500, +0.0250, -0.0250};
static double SdLensP20Y[33] = { -1.0000, -0.8680, -0.7360, -0.6030, -0.4690, -0.3350, -0.2010, -0.0670, +0.0670, +0.2010, +0.3350, +0.4690, +0.6030, +0.7360, +0.8680, +1.0000, +1.0000, +0.8680, +0.7360, +0.6030, +0.4690, +0.3350, +0.2010, +0.0670, -0.0670, -0.2010, -0.3350, -0.4690, -0.6030, -0.7360, -0.8680, -1.0000, -1.0000};
static int SiLensP20N = 33;

static double SdLensP15X[31] = { +0.0000, -0.0340, -0.0630, -0.0870, -0.1060, -0.1210, -0.1300, -0.1350, -0.1350, -0.1300, -0.1210, -0.1060, -0.0870, -0.0630, -0.0340, +0.0000, +0.0340, +0.0630, +0.0870, +0.1060, +0.1210, +0.1300, +0.1350, +0.1350, +0.1300, +0.1210, +0.1060, +0.0870, +0.0630, +0.0340, +0.0000};
static double SdLensP15Y[31] = { -1.0000, -0.8690, -0.7370, -0.6050, -0.4710, -0.3370, -0.2020, -0.0670, +0.0670, +0.2020, +0.3370, +0.4710, +0.6050, +0.7370, +0.8690, +1.0000, +0.8690, +0.7370, +0.6050, +0.4710, +0.3370, +0.2020, +0.0670, -0.0670, -0.2020, -0.3370, -0.4710, -0.6050, -0.7370, -0.8690, -1.0000};
static int SiLensP15N = 31;

static double SdLensP12X[31] = { +0.0000, -0.0420, -0.0790, -0.1090, -0.1340, -0.1520, -0.1650, -0.1710, -0.1710, -0.1650, -0.1520, -0.1340, -0.1090, -0.0790, -0.0420, +0.0000, +0.0420, +0.0790, +0.1090, +0.1340, +0.1520, +0.1650, +0.1710, +0.1710, +0.1650, +0.1520, +0.1340, +0.1090, +0.0790, +0.0420, +0.0000};
static double SdLensP12Y[31] = { -1.0000, -0.8710, -0.7400, -0.6070, -0.4740, -0.3390, -0.2040, -0.0680, +0.0680, +0.2040, +0.3390, +0.4740, +0.6070, +0.7400, +0.8710, +1.0000, +0.8710, +0.7400, +0.6070, +0.4740, +0.3390, +0.2040, +0.0680, -0.0680, -0.2040, -0.3390, -0.4740, -0.6070, -0.7400, -0.8710, -1.0000};
static int SiLensP12N = 31;

static double SdLensP10X[31] = { +0.0000, -0.0510, -0.0960, -0.1330, -0.1630, -0.1850, -0.2000, -0.2080, -0.2080, -0.2000, -0.1850, -0.1630, -0.1330, -0.0960, -0.0510, +0.0000, +0.0510, +0.0960, +0.1330, +0.1630, +0.1850, +0.2000, +0.2080, +0.2080, +0.2000, +0.1850, +0.1630, +0.1330, +0.0960, +0.0510, +0.0000};
static double SdLensP10Y[31] = { -1.0000, -0.8730, -0.7430, -0.6110, -0.4770, -0.3420, -0.2060, -0.0690, +0.0690, +0.2060, +0.3420, +0.4770, +0.6110, +0.7430, +0.8730, +1.0000, +0.8730, +0.7430, +0.6110, +0.4770, +0.3420, +0.2060, +0.0690, -0.0690, -0.2060, -0.3420, -0.4770, -0.6110, -0.7430, -0.8730, -1.0000};
static int SiLensP10N = 31;

static double SdLensP08X[31] = { +0.0000, -0.0660, -0.1220, -0.1700, -0.2090, -0.2380, -0.2570, -0.2670, -0.2670, -0.2570, -0.2380, -0.2090, -0.1700, -0.1220, -0.0660, +0.0000, +0.0660, +0.1220, +0.1700, +0.2090, +0.2380, +0.2570, +0.2670, +0.2670, +0.2570, +0.2380, +0.2090, +0.1700, +0.1220, +0.0660, +0.0000};
static double SdLensP08Y[31] = { -1.0000, -0.8770, -0.7490, -0.6180, -0.4840, -0.3470, -0.2090, -0.0700, +0.0700, +0.2090, +0.3470, +0.4840, +0.6180, +0.7490, +0.8770, +1.0000, +0.8770, +0.7490, +0.6180, +0.4840, +0.3470, +0.2090, +0.0700, -0.0700, -0.2090, -0.3470, -0.4840, -0.6180, -0.7490, -0.8770, -1.0000};
static int SiLensP08N = 31;

static double SdLensP07X[31] = { +0.0000, -0.0760, -0.1430, -0.1990, -0.2440, -0.2780, -0.3010, -0.3120, -0.3120, -0.3010, -0.2780, -0.2440, -0.1990, -0.1430, -0.0760, +0.0000, +0.0760, +0.1430, +0.1990, +0.2440, +0.2780, +0.3010, +0.3120, +0.3120, +0.3010, +0.2780, +0.2440, +0.1990, +0.1430, +0.0760, +0.0000};
static double SdLensP07Y[31] = { -1.0000, -0.8800, -0.7550, -0.6250, -0.4900, -0.3520, -0.2120, -0.0710, +0.0710, +0.2120, +0.3520, +0.4900, +0.6250, +0.7550, +0.8800, +1.0000, +0.8800, +0.7550, +0.6250, +0.4900, +0.3520, +0.2120, +0.0710, -0.0710, -0.2120, -0.3520, -0.4900, -0.6250, -0.7550, -0.8800, -1.0000};
static int SiLensP07N = 31;

static double SdLensP06X[31] = { +0.0000, -0.0920, -0.1720, -0.2400, -0.2960, -0.3380, -0.3660, -0.3800, -0.3800, -0.3660, -0.3380, -0.2960, -0.2400, -0.1720, -0.0920, +0.0000, +0.0920, +0.1720, +0.2400, +0.2960, +0.3380, +0.3660, +0.3800, +0.3800, +0.3660, +0.3380, +0.2960, +0.2400, +0.1720, +0.0920, +0.0000};
static double SdLensP06Y[31] = { -1.0000, -0.8870, -0.7650, -0.6360, -0.5010, -0.3610, -0.2180, -0.0730, +0.0730, +0.2180, +0.3610, +0.5010, +0.6360, +0.7650, +0.8870, +1.0000, +0.8870, +0.7650, +0.6360, +0.5010, +0.3610, +0.2180, +0.0730, -0.0730, -0.2180, -0.3610, -0.5010, -0.6360, -0.7650, -0.8870, -1.0000};
static int SiLensP06N = 31;

static double SdLensP05X[31] = { +0.0000, -0.1180, -0.2220, -0.3110, -0.3850, -0.4410, -0.4790, -0.4980, -0.4980, -0.4790, -0.4410, -0.3850, -0.3110, -0.2220, -0.1180, +0.0000, +0.1180, +0.2220, +0.3110, +0.3850, +0.4410, +0.4790, +0.4980, +0.4980, +0.4790, +0.4410, +0.3850, +0.3110, +0.2220, +0.1180, +0.0000};
static double SdLensP05Y[31] = { -1.0000, -0.9000, -0.7860, -0.6600, -0.5240, -0.3800, -0.2300, -0.0770, +0.0770, +0.2300, +0.3800, +0.5240, +0.6600, +0.7860, +0.9000, +1.0000, +0.9000, +0.7860, +0.6600, +0.5240, +0.3800, +0.2300, +0.0770, -0.0770, -0.2300, -0.3800, -0.5240, -0.6600, -0.7860, -0.9000, -1.0000};
static int SiLensP05N = 31;


//===Interfaces===========================================
static double SdPlateM15X[15] = { -0.1360, -0.1000, -0.0690, -0.0450, -0.0250, -0.0110, -0.0030, +0.0000, -0.0030, -0.0110, -0.0250, -0.0450, -0.0690, -0.1000, -0.1360};
static double SdPlateM15Y[15] = { -1.0000, -0.8600, -0.7190, -0.5760, -0.4330, -0.2890, -0.1450, +0.0000, +0.1450, +0.2890, +0.4330, +0.5760, +0.7190, +0.8600, +1.0000};
static int SiPlateM15N = 15;

static double SdPlateM25X[15] = { -0.0810, -0.0590, -0.0410, -0.0260, -0.0150, -0.0070, -0.0020, +0.0000, -0.0020, -0.0070, -0.0150, -0.0260, -0.0410, -0.0590, -0.0810};
static double SdPlateM25Y[15] = { -1.0000, -0.8580, -0.7160, -0.5730, -0.4300, -0.2870, -0.1430, +0.0000, +0.1430, +0.2870, +0.4300, +0.5730, +0.7160, +0.8580, +1.0000};
static int SiPlateM25N = 15;

static double SdPlateX[2] = { +0.0000, +0.0000};
static double SdPlateY[2] = { -1.0000, +1.0000};
static int SiPlateN = 2;

static double SdPlateP25X[15] = { +0.0810, +0.0590, +0.0410, +0.0260, +0.0150, +0.0070, +0.0020, +0.0000, +0.0020, +0.0070, +0.0150, +0.0260, +0.0410, +0.0590, +0.0810};
static double SdPlateP25Y[15] = { -1.0000, -0.8580, -0.7160, -0.5730, -0.4300, -0.2870, -0.1430, +0.0000, +0.1430, +0.2870, +0.4300, +0.5730, +0.7160, +0.8580, +1.0000};
static int SiPlateP25N = 15;

static double SdPlateP15X[15] = { +0.1360, +0.1000, +0.0690, +0.0450, +0.0250, +0.0110, +0.0030, +0.0000, +0.0030, +0.0110, +0.0250, +0.0450, +0.0690, +0.1000, +0.1360};
static double SdPlateP15Y[15] = { -1.0000, -0.8600, -0.7190, -0.5760, -0.4330, -0.2890, -0.1450, +0.0000, +0.1450, +0.2890, +0.4330, +0.5760, +0.7190, +0.8600, +1.0000};
static int SiPlateP15N = 15;


//===Source and Screen====================================
//---Source-------------------------------------
static double SdSourceX[] = {-1.11,-0.90, 9.99,-0.69,-0.90, 9.99,-0.90,-0.90, 9.99,-0.90,-0.90, 9.99,-0.69,-0.90, 9.99,-1.11,-0.90, 9.99,-1.20,-0.40,-0.47, 0.00,-0.47,-0.40, 9.99,-0.00,-0.00};
static double SdSourceY[] = { 0.21, 0.00, 9.99,-0.21, 0.00, 9.99, 0.30, 0.00, 9.99,-0.30, 0.00, 9.99, 0.21, 0.00, 9.99,-0.21, 0.00, 9.99, 0.00, 0.00, 0.25, 0.00,-0.25, 0.00, 9.99, 1.00,-1.00};
static int SiNumSource = 27;

//---Screen-------------------------------------
static double SdScreenX[26] = { +0.0000, +0.0000, +9.9999, +0.0000, +0.0000, +9.9999, +0.0000, +0.0000, +9.9999, +0.0000, +0.0000, +9.9999, +0.0000, +0.0000, +9.9999, +0.0000, +0.0000, +9.9999, +0.0000, +0.0000, +9.9999, -0.1300, +0.1300, +9.9999, -0.1300, +0.1300};
static double SdScreenY[26] = { -1.0000, -0.8000, +9.9999, -0.7000, -0.5000, +9.9999, -0.4000, -0.2000, +9.9999, -0.1000, +0.1000, +9.9999, +0.2000, +0.4000, +9.9999, +0.5000, +0.7000, +9.9999, +0.8000, +1.0000, +9.9999, +1.0000, +1.0000, +9.9999, -1.0000, -1.0000};
static int SiScreenN = 26;

/*********************************************************
* fnPaintIcon Macro
*********************************************************/
#define fnPaintIcon(hdc, x0, y0, dCosA, dSinA, pdX, pdY, N) {\
   for(int k=-1; k<(N); k++) {\
      if(k<0 || (pdX)[k] > 9.00) {\
         k++;\
         MoveToEx((hdc),\
            (int)((x0) + (dCosA)*(pdX)[k] + (dSinA)*(pdY)[k]),\
            (int)((y0) - (dSinA)*(pdX)[k] + (dCosA)*(pdY)[k]), NULL);\
      } else {\
         LineTo((hdc),\
            (int)((x0) + (dCosA)*(pdX)[k] + (dSinA)*(pdY)[k]),\
            (int)((y0) - (dSinA)*(pdX)[k] + (dCosA)*(pdY)[k]));\
      }\
   }\
}



/*********************************************************
* Mirror
* Can be plane, convex, or concave.
* The hero mirror data has curvatures positive / negative
* 5, 6, 7, 8, 10, 12, 15, 20, 30, 50, and plane. The cut-
* off values were calculated using
*    round(([5 6 7 8 10 12 15 20 30 50]' * 5).^1.3)
* to get some sort of automated scaling
*********************************************************/
void Renderer2dMirror(HDC hdc, int x, int y, double dSize, double dAbsAng, double dROC) {
   double dCosA = (double) (dSize * COS(dAbsAng)) / 2.00;
   double dSinA = (double) (dSize * SIN(dAbsAng)) / 2.00;

   if     (dROC==  0.00) fnPaintIcon(hdc, x, y, dCosA, dSinA, SdMirrX,    SdMirrY,    SiMirrN)
   else if(dROC<-674.00) fnPaintIcon(hdc, x, y, dCosA, dSinA, SdMirrM50X, SdMirrM50Y, SiMirrM50N)
   else if(dROC<-389.00) fnPaintIcon(hdc, x, y, dCosA, dSinA, SdMirrM30X, SdMirrM30Y, SiMirrM30N)
   else if(dROC<-274.00) fnPaintIcon(hdc, x, y, dCosA, dSinA, SdMirrM20X, SdMirrM20Y, SiMirrM20N)
   else if(dROC<-205.00) fnPaintIcon(hdc, x, y, dCosA, dSinA, SdMirrM15X, SdMirrM15Y, SiMirrM15N)
   else if(dROC<-162.00) fnPaintIcon(hdc, x, y, dCosA, dSinA, SdMirrM12X, SdMirrM12Y, SiMirrM12N)
   else if(dROC<-121.00) fnPaintIcon(hdc, x, y, dCosA, dSinA, SdMirrM10X, SdMirrM10Y, SiMirrM10N)
   else if(dROC<-102.00) fnPaintIcon(hdc, x, y, dCosA, dSinA, SdMirrM08X, SdMirrM08Y, SiMirrM08N)
   else if(dROC<- 83.00) fnPaintIcon(hdc, x, y, dCosA, dSinA, SdMirrM07X, SdMirrM07Y, SiMirrM07N)
   else if(dROC<- 66.00) fnPaintIcon(hdc, x, y, dCosA, dSinA, SdMirrM06X, SdMirrM06Y, SiMirrM06N)
   else if(dROC<-  0.00) fnPaintIcon(hdc, x, y, dCosA, dSinA, SdMirrM05X, SdMirrM05Y, SiMirrM05N)

   else if(dROC<  66.00) fnPaintIcon(hdc, x, y, dCosA, dSinA, SdMirrP05X, SdMirrP05Y, SiMirrP05N)
   else if(dROC<  83.00) fnPaintIcon(hdc, x, y, dCosA, dSinA, SdMirrP06X, SdMirrP06Y, SiMirrP06N)
   else if(dROC< 102.00) fnPaintIcon(hdc, x, y, dCosA, dSinA, SdMirrP07X, SdMirrP07Y, SiMirrP07N)
   else if(dROC< 121.00) fnPaintIcon(hdc, x, y, dCosA, dSinA, SdMirrP08X, SdMirrP08Y, SiMirrP08N)
   else if(dROC< 162.00) fnPaintIcon(hdc, x, y, dCosA, dSinA, SdMirrP10X, SdMirrP10Y, SiMirrP10N)
   else if(dROC< 205.00) fnPaintIcon(hdc, x, y, dCosA, dSinA, SdMirrP12X, SdMirrP12Y, SiMirrP12N)
   else if(dROC< 274.00) fnPaintIcon(hdc, x, y, dCosA, dSinA, SdMirrP15X, SdMirrP15Y, SiMirrP15N)
   else if(dROC< 389.00) fnPaintIcon(hdc, x, y, dCosA, dSinA, SdMirrP20X, SdMirrP20Y, SiMirrP20N)
   else if(dROC< 674.00) fnPaintIcon(hdc, x, y, dCosA, dSinA, SdMirrP30X, SdMirrP30Y, SiMirrP30N)
   else               fnPaintIcon(hdc, x, y, dCosA, dSinA, SdMirrP50X, SdMirrP50Y, SiMirrP50N)
}

/*********************************************************
* MirrorLock
* Paints an icon to represent a locked mirror angle
*********************************************************/
void Renderer2dMirrorLock(HDC hdc, int x, int y, double dSize, double dAbsAng) {
   double dCosA = (double) (dSize * COS(dAbsAng)) / 2.00;
   double dSinA = (double) (dSize * SIN(dAbsAng)) / 2.00;
   fnPaintIcon(hdc, x, y, dCosA, dSinA, SdMirrLkX, SdMirrLkY, SiMirrLkN);
}

/*********************************************************
* SysSpawn
* Paints an icon to represent the mirror spawns another
* system.
*********************************************************/
void Renderer2dSysSpawn(HDC hdc, int x, int y, double dSize, double dAbsAng) {
   double dCosA = (double) (dSize * COS(dAbsAng)) / 2.00;
   double dSinA = (double) (dSize * SIN(dAbsAng)) / 2.00;
   fnPaintIcon(hdc, x, y, dCosA, dSinA, SdSpawnSysX, SdSpawnSysY, SiNumSpawnSys);
}

/*********************************************************
* OpticGraph
* Unlike others, the icon is never rotated, but its posi-
* tion moves with the optic.
*********************************************************/
void Renderer2dOpticGraph(HDC hdc, int x, int y, double dSize, double dAbsAng) {
   while(dAbsAng > M_PI_2) dAbsAng -= M_PI;
   while(dAbsAng <-M_PI_2) dAbsAng += M_PI;
   x += dSize * SIN(dAbsAng);
   y += dSize * COS(dAbsAng);
   fnPaintIcon(hdc, x, y, dSize, 0.00, SdGraphX, SdGraphY, SiGraphN);
}

/*********************************************************
* Renderer2dLens
* Note swapped X and Y! (<-- What does this mean?)
*********************************************************/
void Renderer2dLens(HDC hdc, int x, int y, double dSize, double dAbsAng, double dFL) {
   double dCosA = (double) (dSize * COS(dAbsAng)) / 2.00;
   double dSinA = (double) (dSize * SIN(dAbsAng)) / 2.00;

   if     (dFL==  0.00) fnPaintIcon(hdc, x, y, dCosA, dSinA, SdLensX,    SdLensY,    SiLensN)
   else if(dFL<-389.00) fnPaintIcon(hdc, x, y, dCosA, dSinA, SdLensM30X, SdLensM30Y, SiLensM30N)
   else if(dFL<-274.00) fnPaintIcon(hdc, x, y, dCosA, dSinA, SdLensM20X, SdLensM20Y, SiLensM20N)
   else if(dFL<-205.00) fnPaintIcon(hdc, x, y, dCosA, dSinA, SdLensM15X, SdLensM15Y, SiLensM15N)
   else if(dFL<-162.00) fnPaintIcon(hdc, x, y, dCosA, dSinA, SdLensM12X, SdLensM12Y, SiLensM12N)
   else if(dFL<-121.00) fnPaintIcon(hdc, x, y, dCosA, dSinA, SdLensM10X, SdLensM10Y, SiLensM10N)
   else if(dFL<-102.00) fnPaintIcon(hdc, x, y, dCosA, dSinA, SdLensM08X, SdLensM08Y, SiLensM08N)
   else if(dFL<- 83.00) fnPaintIcon(hdc, x, y, dCosA, dSinA, SdLensM07X, SdLensM07Y, SiLensM07N)
   else if(dFL<- 66.00) fnPaintIcon(hdc, x, y, dCosA, dSinA, SdLensM06X, SdLensM06Y, SiLensM06N)
   else if(dFL<-  0.00) fnPaintIcon(hdc, x, y, dCosA, dSinA, SdLensM05X, SdLensM05Y, SiLensM05N)

   else if(dFL<  66.00) fnPaintIcon(hdc, x, y, dCosA, dSinA, SdLensP05X, SdLensP05Y, SiLensP05N)
   else if(dFL<  83.00) fnPaintIcon(hdc, x, y, dCosA, dSinA, SdLensP06X, SdLensP06Y, SiLensP06N)
   else if(dFL< 102.00) fnPaintIcon(hdc, x, y, dCosA, dSinA, SdLensP07X, SdLensP07Y, SiLensP07N)
   else if(dFL< 121.00) fnPaintIcon(hdc, x, y, dCosA, dSinA, SdLensP08X, SdLensP08Y, SiLensP08N)
   else if(dFL< 162.00) fnPaintIcon(hdc, x, y, dCosA, dSinA, SdLensP10X, SdLensP10Y, SiLensP10N)
   else if(dFL< 205.00) fnPaintIcon(hdc, x, y, dCosA, dSinA, SdLensP12X, SdLensP12Y, SiLensP12N)
   else if(dFL< 274.00) fnPaintIcon(hdc, x, y, dCosA, dSinA, SdLensP15X, SdLensP15Y, SiLensP15N)
   else if(dFL< 389.00) fnPaintIcon(hdc, x, y, dCosA, dSinA, SdLensP20X, SdLensP20Y, SiLensP20N)
   else              fnPaintIcon(hdc, x, y, dCosA, dSinA, SdLensP30X, SdLensP30Y, SiLensP30N)

}
///TODO: Let's get rid of the floats here

/*********************************************************
* Renderer2dSource
*********************************************************/
void Renderer2dSource(HDC hdc, int x, int y, double dSize, double dAbsAng) {
   double dCosA = (double) (dSize * COS(dAbsAng)) / 2.00;
   double dSinA = (double) (dSize * SIN(dAbsAng)) / 2.00;
   fnPaintIcon(hdc, x, y, dCosA, dSinA, SdSourceX, SdSourceY, SiNumSource);
}


/*********************************************************
* Renderer2dScreen
*********************************************************/
void Renderer2dScreen(HDC hdc, int x, int y, double dSize, double dAbsAng) {
   double dCosA = (double) (dSize * COS(dAbsAng)) / 2.00;
   double dSinA = (double) (dSize * SIN(dAbsAng)) / 2.00;
   fnPaintIcon(hdc, x, y, dCosA, dSinA, SdScreenX, SdScreenY, SiScreenN);
}

/*********************************************************
* Renderer2dPlate
* This handles  all the plate, crystal, and  Brewster-cut
* crystal interfaces.
* When painting, there is a small problem that curved in-
* terfaces will cut each other  for short lengths. To mi-
* nimize the effect, we have only  weakly curved or plane
* interfaces. Simply  offsetting the curved face, as done
* for the lenses above, doesn't work, because each inter-
* face is a separate entity and  should cross the center-
* line at the canvas point.
*********************************************************/
void Renderer2dPlate(HDC hdc, int x, int y, double dSize, double dAbsAng, double dROC) {
   double dCosA = (double) BLOCKSIZE*(dSize * COS(dAbsAng)) / 2.00;
   double dSinA = (double) BLOCKSIZE*(dSize * SIN(dAbsAng)) / 2.00;

   if     (dROC==  0.00) fnPaintIcon(hdc, x, y, dCosA, dSinA, SdPlateX,    SdPlateY,    SiPlateN)
   else if(dROC<-118.00) fnPaintIcon(hdc, x, y, dCosA, dSinA, SdPlateP25X, SdPlateP25Y, SiPlateP25N)
   else if(dROC<   0.00) fnPaintIcon(hdc, x, y, dCosA, dSinA, SdPlateP15X, SdPlateP15Y, SiPlateP15N)
   else if(dROC< 118.00) fnPaintIcon(hdc, x, y, dCosA, dSinA, SdPlateM15X, SdPlateM15Y, SiPlateM15N)
   else                  fnPaintIcon(hdc, x, y, dCosA, dSinA, SdPlateM25X, SdPlateM25Y, SiPlateM25N)

}



/*********************************************************
* Renderer2dPrism
*********************************************************/
///TODO: CHECK MATH ON THIS
///TODO: Eliminate trig functions from this
void Renderer2dPrism (HDC hdc, int x, int y, double dSize, double dAbsAng, double dRefIndx) {
   if(dRefIndx<1.00) dRefIndx = 1.00;
   double dApexHalfAng = M_PI_2 - ATAN(dRefIndx);
   double dX[4] = {0.00, 0.00, 0.00, 0.00};
   double dY[4] = {0.00, 0.00, 0.00, 0.00};

   dX[1] = -(dX[2] = 0.65 * SIN(dApexHalfAng));
   dY[1] =   dY[2] = 0.65 * COS(dApexHalfAng);

   double dCosA = (double) (dSize * COS(dAbsAng));
   double dSinA = (double) (dSize * SIN(dAbsAng));
   fnPaintIcon(hdc, x, y, dCosA, dSinA, dX, dY, 4);
}



/*########################################################
 ## Patch Objects                                      ##
########################################################*/
/*********************************************************
* PatchPlate
* Only call this for input face
*********************************************************/
#define fnAppendUp(NTot, ptCoords, x0, y0, dCosA, dSinA, pdX, pdY, N) {\
   for(int k=0; k<(N); k++) {\
      (ptCoords)[(NTot)].x = (x0) + (dCosA)*(pdX)[k] + (dSinA)*(pdY)[k];\
      (ptCoords)[(NTot)].y = (y0) - (dSinA)*(pdX)[k] + (dCosA)*(pdY)[k];\
      (NTot)++;\
   }\
}
#define fnAppendDown(NTot, ptCoords, x0, y0, dCosA, dSinA, pdX, pdY, N) {\
   for(int k=0; k<(N); k++) {\
      (ptCoords)[(NTot)].x = (x0) + (dCosA)*(pdX)[(N)-1-k] + (dSinA)*(pdY)[(N)-1-k];\
      (ptCoords)[(NTot)].y = (y0) - (dSinA)*(pdX)[(N)-1-k] + (dCosA)*(pdY)[(N)-1-k];\
      (NTot)++;\
   }\
}
//********************************************************
void Renderer2dPatchPlate(HDC hdc, int x0, int y0, double dAng0, double dROC0, int x1, int y1, double dAng1, double dROC1, double dSize) {
   double dCosA, dSinA;                     // trig values
   int   NTotal;                            // total number of points
   POINT ptCoords[32];                      // coordinates (must be large enough for highest res pair)

   //---First interface-------------------------
   NTotal = 0;
   dCosA = BLOCKSIZE * dSize * COS(dAng0) / 2.00;
   dSinA = BLOCKSIZE * dSize * SIN(dAng0) / 2.00;
   if     (dROC0==  0.00) fnAppendUp(NTotal, ptCoords, x0, y0, dCosA, dSinA, SdPlateX,    SdPlateY,    SiPlateN)
   else if(dROC0<-118.00) fnAppendUp(NTotal, ptCoords, x0, y0, dCosA, dSinA, SdPlateP25X, SdPlateP25Y, SiPlateP25N)
   else if(dROC0<   0.00) fnAppendUp(NTotal, ptCoords, x0, y0, dCosA, dSinA, SdPlateP15X, SdPlateP15Y, SiPlateP15N)
   else if(dROC0< 118.00) fnAppendUp(NTotal, ptCoords, x0, y0, dCosA, dSinA, SdPlateM15X, SdPlateM15Y, SiPlateM15N)
   else                   fnAppendUp(NTotal, ptCoords, x0, y0, dCosA, dSinA, SdPlateM25X, SdPlateM25Y, SiPlateM25N)

   //---Second interface------------------------
   // Note flipped +/-
   dCosA = BLOCKSIZE * dSize * COS(dAng1) / 2.00;
   dSinA = BLOCKSIZE * dSize * SIN(dAng1) / 2.00;
   if     (dROC1==  0.00) fnAppendDown(NTotal, ptCoords, x1, y1, dCosA, dSinA, SdPlateX,    SdPlateY,    SiPlateN)
   else if(dROC1<-118.00) fnAppendDown(NTotal, ptCoords, x1, y1, dCosA, dSinA, SdPlateM25X, SdPlateM25Y, SiPlateM25N)
   else if(dROC1<   0.00) fnAppendDown(NTotal, ptCoords, x1, y1, dCosA, dSinA, SdPlateM15X, SdPlateM15Y, SiPlateM15N)
   else if(dROC1< 118.00) fnAppendDown(NTotal, ptCoords, x1, y1, dCosA, dSinA, SdPlateP15X, SdPlateP15Y, SiPlateP15N)
   else                   fnAppendDown(NTotal, ptCoords, x1, y1, dCosA, dSinA, SdPlateP25X, SdPlateP25Y, SiPlateP25N)

   //---Patch-----------------------------------
   Polygon(hdc, ptCoords, NTotal);

}


/*********************************************************
* PatchPrism
*********************************************************/
void Renderer2dPatchPrism(HDC hdc, int x0, int y0, double dAng0, int x1, int y1, double dAng1, double dSize, double dRefIndx) {
   if(dRefIndx<1.00) dRefIndx = 1.00;       // ensure physical refractive index
   double dApexHalfAng = M_PI_2 - ATAN(dRefIndx); // calculate apex half-angle
   double dX[3] = {0.00, 1.20,-1.20};       // X coordinates, calculated below
   double dY[3] = {0.00, 2.00, 2.00};       // default Y coordinates
   POINT  ptCoords[3];                      // coordinates for Polygon()
   int    k;                                // loop counter

   dX[1] = -(dX[2] = 0.65 * SIN(dApexHalfAng));
   dY[1] =   dY[2] = 0.65 * COS(dApexHalfAng);

   //---First---------------
   double dCosA = (double) (dSize * COS(dAng0));
   double dSinA = (double) (dSize * SIN(dAng0));
   for(k=0; k<3; k++) {
      ptCoords[k].x = x0 + (dCosA)*dX[k] + (dSinA)*dY[k];
      ptCoords[k].y = y0 - (dSinA)*dX[k] + (dCosA)*dY[k];
   }
   Polygon(hdc, ptCoords, 3);

   //---Second--------------
   dCosA = (double) (dSize * COS(dAng1));
   dSinA = (double) (dSize * SIN(dAng1));
   for(k=0; k<3; k++) {
      ptCoords[k].x = x1 + (dCosA)*dX[k] + (dSinA)*dY[k];
      ptCoords[k].y = y1 - (dSinA)*dX[k] + (dCosA)*dY[k];
   }
   Polygon(hdc, ptCoords, 3);
}


/*########################################################
 ## Mode                                               ##
########################################################*/

/*********************************************************
* Renderer2dMode
* As in previous versions of  LaserCanvas, we use a near-
* field / far field split for the  mode size for display,
* since that gives the  best economy in terms of plotting
* points and visual appeal. The measurement tools must do
* their own, accurate, calculations.
* The mode size propagation formula is given by
*               __________________
*              /       /  z  \ 2  `
*   w  =  w0  /  1  + | ----- |
*           \/         \  zR /
* where
*           lambda
*    zR =  ---------
*           pi w0^2
* This can be approximated for
*  z/zR << 1:   w ~ w0 (1 + z/zR)^2 (NOT USED)
*  z/zR >> 1:   w ~ w0 |z/zR| (single far-field point)
* For intermediate  values of z, we use  a look-up table.
* It turns out that 14 points per half are sufficient. We
* use the variable S to represent z/zR, but is not calcu-
* lated by this function.
*
* In this version, rather than storing the values, we im-
* plement a slightly longer code switchyard and calculate
* the  points every time they  need to be plotted.  Since
* each renderer has its own zoom and orientations anyway,
* this isn't as wasteful as it seems.
*********************************************************/
//const float ModeS[] = {0.100000, 0.150000, 0.200000, 0.250000, 0.300000, 0.350000, 0.400000, 0.450000, 0.500000, 0.600000, 0.700000, 0.800000, 0.900000, 1.000000, 1.200000, 1.400000, 1.600000, 1.800000, 2.000000, 2.500000, 3.000000, 3.500000, 4.000000, 5.000000, 6.000000, 7.000000, 8.000000, 10.000000};
//const float ModeW[] = {1.004988, 1.011187, 1.019804, 1.030776, 1.044031, 1.059481, 1.077033, 1.096586, 1.118034, 1.166190, 1.220656, 1.280625, 1.345362, 1.414214, 1.562050, 1.720465, 1.886796, 2.059126, 2.236068, 2.692582, 3.162278, 3.640055, 4.123106, 5.099020, 6.082763, 7.071068, 8.062258, 10.049876};
//const int   nMode = 28;                     // 28 data points
static double SdGFXModeS[] = {0.100000, 0.200000, 0.300000, 0.400000, 0.500000, 0.700000, 0.900000, 1.200000, 1.600000, 2.000000, 3.000000, 4.000000, 6.000000, 8.000000, 10.000000};
static double SdGFXModeW[] = {1.004988, 1.019804, 1.044031, 1.077033, 1.118034, 1.220656, 1.345362, 1.562050, 1.886796, 2.236068, 3.162278, 4.123106, 6.082763, 8.062258, 10.049876};
static int   SiGFXMode = 15;                 // 15 data points
//********************************************************
#define fnModeX(S, W) (x0 + (S)*dLCosA + (W)*dWSinA)
#define fnModeY(S, W) (y0 + (S)*dLSinA - (W)*dWCosA)
#define fnMarker(hdc, x, y) {\
MoveToEx(hdc,(x),(y),NULL); LineTo(hdc,(x)-2,(y));LineTo(hdc,(x)+3,(y));\
MoveToEx(hdc,(x),(y),NULL); LineTo(hdc,(x),(y)-2);LineTo(hdc,(x),(y)+3);\
MoveToEx(hdc,(x),(y),NULL);}
//********************************************************
void Renderer2dMode(HDC hdc, int xVx, int yVx, double dAbsAng, double dModeSize, double dLenSeg, double w0, double z0, double zR, double zMax, BOOL tfWaist) {
   int    k;                                // table index
   int    iStp;                             // step size
   int    iDir;                             // mode plot: up and down
   int    x0, y0;                           // waist position on screen (for easier referencing)
   double dSMin, dSMax;                     // minimum and maximum scaled distances
   double dLScl;                            // scale distance (S to screen)
   double dLCosA, dLSinA;                   // scale distance trig functions
   double dWCosA, dWSinA;                   // waist size trig functions

   //===Preliminaries=====================================
///TODO: More accurate step size estimation
   //---Scale distance--------------------------
   if(zR==0.00) zR = 1.00;                  // prevent #DIV/0! errors
   dSMin = -z0 / zR;                        // starting scaled distance
   dSMax = (zMax-z0) / zR;                  // ending scaled distance
   if((dSMax-dSMin)==0.00) dSMax = dSMin + 1.00; // prevent #DIV/0! (shouldn't happen)
   dLScl = dLenSeg / (dSMax - dSMin);       // scale distance to screen
   iStp =(dLScl<0.10) ? SiGFXMode :         // don't plot all points unless needed
         (dLScl<1.00) ? 2 : 1;

   //---Trig functions--------------------------
   dLCosA = dLScl * COS(dAbsAng);
   dLSinA = dLScl * SIN(dAbsAng);
   dWCosA = dModeSize * w0 * COS(dAbsAng);
   dWSinA = dModeSize * w0 * SIN(dAbsAng);

   //---Waist position--------------------------
   x0 = xVx + (int) (-dSMin * dLCosA);      // screen waist position
   y0 = yVx + (int) (-dSMin * dLSinA);
   if(tfWaist && (dSMin<0.00) && (dSMax>0.00)) {
      MoveToEx(hdc, x0-dWSinA, y0+dWCosA, NULL);
      LineTo  (hdc, x0+dWSinA, y0-dWCosA);
   }

   //===Paint each half===================================
   // I've tried to symmetrise the code a bit here. It is
   // possible that the number of tests could be reduced,
   // but this way seems tidier.
   // Notes
   //  - dSMin and dSMax MUST be in ascending order.
   //  - The dwTrgA trig functions multiply by w0, so the
   //    first and last data points, which are calculated
   //    from the propagation  formula proper, do not in-
   //    clude w0 explicitly.
   for(iDir=-1; iDir<=1; iDir+=2) {         // once up, once down
      //---Flip direction----------------
      dWCosA = -dWCosA;                     // equivalent to plotting..
      dWSinA = -dWSinA;                     //..with negative waist!

      //---First optic-------------------
      MoveToEx(hdc,
         fnModeX(dSMin, SQRT(1+SQR(dSMin))),
         fnModeY(dSMin, SQRT(1+SQR(dSMin))),
         NULL);

      //---Backwards table---------------
      if(dSMin < 0.00) {                    // don't check table unless we have to
         for(k=SiGFXMode-1; (k>=0)&&(-SdGFXModeS[k]<dSMin); k-=iStp); // skip points behind start
         for(;(k>=0)&&(-SdGFXModeS[k]<=dSMax);k-=iStp) {
            LineTo(hdc,
               fnModeX(-SdGFXModeS[k], SdGFXModeW[k]),
               fnModeY(-SdGFXModeS[k], SdGFXModeW[k]));
//fnMarker(hdc, fnModeX(-SdGFXModeS[k], SdGFXModeW[k]), fnModeY(-SdGFXModeS[k], SdGFXModeW[k]));
         }
      }

      //---Waist-------------------------
      if((dSMin<0.00) && (dSMax>0.00)) {
         LineTo(hdc, fnModeX(0.00, 1.00), fnModeY(0.00, 1.00));
      }

      //---Forwards table----------------
      if(dSMax > 0.00) {
         for(k=0; (k<SiGFXMode)&&(SdGFXModeS[k]<=dSMax); k+=iStp) {
            if(SdGFXModeS[k] < dSMin) continue;
            LineTo(hdc,
               fnModeX(SdGFXModeS[k], SdGFXModeW[k]),
               fnModeY(SdGFXModeS[k], SdGFXModeW[k]));
//fnMarker(hdc, fnModeX(SdGFXModeS[k], SdGFXModeW[k]), fnModeY(SdGFXModeS[k], SdGFXModeW[k]));
         }
      }

      //---Last optic--------------------
      LineTo(hdc,
         fnModeX(dSMax, SQRT(1+SQR(dSMax))),
         fnModeY(dSMax, SQRT(1+SQR(dSMax))));
   }
}
